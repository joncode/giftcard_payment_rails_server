require 'rest_client'
require "base64"

# Questions :

# 	what is the merchant Site ID
# 	what is the posreferernce - is it the same value as TransactionReference
	# or is it Unique string generated by the POS
# Identifier is unique gift/redemption ID in our system - why do I need this ?

# zapper ID on payment is unique customer reference but on response its unique transaction identifier
# paymentID is a zapper system reference & a ref used for refund , is that accurate  ?
# what does the syncronous resonse look like
# does I have to send in  a loction identifier or a tender type key identifer or does the qr code handle that , ie is qr code unique for all locations ?

RestClient.log = 'stdout'

class OpsZapper
	include MoneyHelper

	SUC_5 = "http://2.zap.pe?t=6&i=71:71:7[34%7C5%7C11,66%7CITSONME_5%7C10:10[39%7CUSD"
	SUC_25 = "http://2.zap.pe?t=6&i=71:71:7[34|25|11,66|ITSONME_25|10:10[39|USD"
	SUC_100 = "http://2.zap.pe?t=6&i=71:71:7[34|100|11,66|ITSONME_100|10:10[39|USD"
	ERRC = "http://2.zap.pe?t=6&i=71:71:7[34%7C25%7C11,66%7CITSONME_FAIL%7C10:10[39%7CGBP"

	CHOOSE_QR = [SUC_5,SUC_25,SUC_100,ERRC]
	if Rails.env.production?
		ZAPPER_NOTIFY_URL = "https://api.itson.me/events/callbacks/zappernotify"
	else
		ZAPPER_NOTIFY_URL = "https://qaapi.itson.me/events/callbacks/zappernotify"
	end
	# ZAP_REQ_URL = "https://zapapi.zapzap.mobi/zapperpointofsale/api"
	ZAP_REQ_URL = ZAPPER_API_URL

#   -------------

	attr_accessor :value, :ccy, :customer, :qr_code, :gift_card_id, :transaction_ref, :code, :applied_value, :ticket_id,
		 :extra_value, :extra_gift, :check_value, :redemption_id, :request, :h, :json, :err_desc

	def initialize args
		@request = args
		# args = { "qr_code" => qr_code, "gift_card_id" => gift.obscured_id,
		#  "value" => redemption.amount, "ccy" => gift.ccy, "redemption_id" => redemption.id }
		@code = 100
		@qr_code = args['qr_code']
		@gift_card_id = args['gift_card_id']
		@value 			 = args['value']
		@applied_value 	 = 0
		@extra_value     = 0
		@extra_gift      = 0
		@check_value 	 = 0
		@ccy = args['ccy']
		@customer = args['customer']
		@redemption_id = args['redemption_id']
		@transaction_ref = args['redemption_id']
		@ticket_id = nil
		@merchant_site_id = 12
	end

	def success?
		(200..299).cover?(@code)
	end

	def response
		response_from_code
	end

#   -------------

	def self.make_request_hsh gift, qr_code, value, redemption_id=nil
		{
			"qr_code" => Base64.encode64(qr_code),
            "gift_card_id" => 'gi_' + gift.obscured_id.to_s,
            "value" => value,
            "ccy" => gift.ccy,
            'customer' => customer(gift.receiver),
            'redemption_id' => redemption_id
        }
	end

	def self.customer user
		h = {
			"FirstName" => user.first_name,
			"LastName" => user.last_name,
			"PhoneNumber" => user.phone,
			"CountryISOCode" => 'US',
			"EmailAddress" => user.email
		}
		if h["PhoneNumber"].blank?
			h["PhoneNumber"] = TWILIO_PHONE_NUMBER.gsub(/[^0-9.]/, '')
		end
		h
	end

#   -------------

	def redeem_gift
		route = "payments/CreateCustomerAndInitiatePayment"
		payload = payment
		post_zapper route, payload
		return response
	end

	def check_result
		route = "payments/GetMultiplePaymentStatusByPosReferences?merchantsiteId=#{@merchant_site_id}&posreference=#{@transaction_ref}"
		get_zapper route
		return response
	end

#   -------------

	def payment qr_code=@qr_code, transaction_ref=@transaction_ref, customer=@customer
		{
				# IOM Unique transaction reference number
		 	"TransactionReference" => transaction_ref,
		 		# Base64 encoded QR code string
			"QRCode" => qr_code,
				# URL to send payment status after completion
			"NotificationUrl" => ZAPPER_NOTIFY_URL,
			"Customer" => customer,
			"Vouchers" => [ voucher ]
		}

	end

	def voucher value=@value, ccy=@ccy, gift_card_id=@gift_card_id
		{
				# Identifier is unique gift/redemption ID in our system
			"Identifier" => gift_card_id,
				# customer readable gift/redemption description
			"Description" => "ItsOnMe Gift Redemption - #{@redemption_id}",
				# amount in cents
			"Amount" => value,
				# ccy iso code - ISO 3166 (ALPHA-3)
			"CurrencyISOCode" => ccy
		}
	end

#   -------------

	def handle_error e
		puts "\n 500 Internal ZAPPER Error code = #{e.class.to_s}|#{e.inspect}\n\n"
        if e.nil?
        	@code = 400
        else
        	if e.kind_of?(Errno::ETIMEDOUT)
        		# timeout error
        		@code = 509
        	else
            	if e.http_code == 401
            		@code = 400
            	else
            		@code = e.http_code
            	end
            end
        end
	end

#   -------------

	def post_zapper route, payload
		puts "\n ZAPPER payload = #{payload}\n"
		# return example_redeem
		puts "POST #{ZAP_REQ_URL}/#{route}"
		begin
			response = RestClient.post(
			    "#{ZAP_REQ_URL}/#{route}",
			    payload.to_json,
			    { content_type: 'application/json', accept: :json, :'Authorization' => "Bearer #{ZAPPER_API_KEY}" }
			)
			@h = response
            puts "\n Here is ZAPPER response #{response.inspect}\n\n"
            resp = JSON.parse response
            @json = resp
            apply_ticket_value(resp)
		rescue => e
			puts "\n Here is ZAPPER error #{e.inspect}\n\n"
			handle_error(e)
		end
	end

    def get_token
		# puts "\n ZAPPER payload = #{route}\n"
		# return example_check
        begin
            response = RestClient.get(
                "#{ZAP_REQ_URL}/oauth/token",
                { :content_type => :json, :'Authorization' => "Bearer #{ZAPPER_API_KEY}"  }
            )
			@h = response
            puts "\n Here is ZAPPER response #{response.inspect}\n\n"
            resp = JSON.parse response
            @json = resp

            # apply_ticket_success(resp)
        rescue => e
            handle_error(e)
        end
    end


    def get_zapper route
		puts "\n ZAPPER payload = #{route}\n"
		# return example_check
        begin
            response = RestClient.get(
                "#{ZAP_REQ_URL}/#{route}",
                { :content_type => :json, :'Authorization' => "Bearer #{ZAPPER_API_KEY}" }
            )
            puts "\n Here is ZAPPER response #{response.inspect}\n\n"
            resp = JSON.parse response
   #          resp = Hash.from_xml(response)["message"]["param"].inject({}) do |result, elem|
			# 	result[elem["name"]] = elem["value"]
			# 	result
			# end
            apply_ticket_success(resp)
        rescue => e
            handle_error(e)
        end
    end

#   -------------

	def apply_ticket_success(resp)
		resp
	end


	def apply_ticket_value resp
		@ticket_id = resp['ZapperId'] + '-' + resp['PaymentId'].to_s
		@check_value = resp['OriginalBillAmount'].to_i
		@err_desc = resp["ErrorDescription"]

		if @err_desc.blank?
			@code = 402
			@applied_value = 0
			@extra_value = @value
		else
			if @value < @check_value
				@code			= 206   # ok , the gift has partially covered the ticket cost
				@extra_value	= @check_value - @value
				@applied_value	= @value
			elsif @value > @check_value
				@code			= 201    # ok , a new gift has been created for the extra gift value
				@extra_gift	    = @value - @check_value
				@applied_value	= @check_value
			else
				@code  = 200   # ok , full aceeptance
				@applied_value	= @value
			end
		end

		resp
	end

#   -------------

	def response_from_code
		case @code
		when 100
			r_code = "OPEN"
			r_text = "Gift has not been redeemed yet."
		when 200
			r_code = "PAID"
			r_text = "#{display_money(cents: @value, ccy: @ccy)} was applied to your check. Transaction completed."
		when 201
			r_code = "OVER_PAID"
			r_text = "Your gift exceeded the check value. Your gift has a balance of #{display_money(cents: @extra_gift, ccy: @ccy)}."
		when 206
			r_code = "APPLIED"
			r_text = "#{display_money(cents: @value, ccy: @ccy)} was applied to your check. A total of #{display_money(cents: @extra_value, ccy: @ccy)} remains to be paid."
		when 304
			r_code = "ERROR"
			r_text = "Check Number #{@ticket_id} has already been paid."
		when 400
				# this could be an authorization error with zapper (401) - must fix bearer auth
				# OpsTwilio.text_devs msg: "400 Error on Zapper"
			r_code = "ERROR"
			r_text = "Internal Error Point of Sale System Unavailable. Please try again later or contact support@itson.me"
		when 404
			r_code = "ERROR"
			r_text = "Your QR-Code cannot be found. Please re-scan and try again. If this issue persists please contact support@itson.me"
		when 401
			r_code = "ERROR"
			r_text = "This gift card is only redeemable for the exact item mentioned. Please order the correct item to use this gift card."
		when 402
			r_code = "ERROR"
			r_text = @err_desc
		when 500
			r_code = "ERROR"
			r_text = "Internal Error Point of Sale System Unavailable. Please try again later or contact support@itson.me"
		when 503
			r_code = "ERROR"
			r_text = "Merchant Point of Sale System Unavailable.  Please try again after a few minutes."
		when 509
			r_code = "ERROR"
			r_text = "Merchant Server Unavailable.  Please try again later."
		else
				# this is an authorization error with zapper - must fix bearer auth
				# OpsTwilio.text_devs msg: "Unknown Error on Zapper"
			r_code = "ERROR"
			r_text = "Server Error.  Please try again later"
		end
		if success?
			hsh = success_hsh
			hsh[:msg] = r_text
			response_data = hsh
		else
			@err_desc = r_text if @err_desc.nil?
			response_data = r_text
		end
		{ "response_code" => r_code, "response_text" => response_data, 'success' => success? }
	end

	def success_hsh
		{
            amount_applied: @applied_value,
            total_check_amount: @check_value,
            remaining_check_balance: @extra_value,
            remaining_gift_balance: @extra_gift
		}
	end


#   -------------


	def example_redeem
		resp = {
				# Action indicator None = 1, RedirectToZapper = 2
			"ActionIndicator" => 2,
				# MerchantSite Identifier
			"MerchantSiteId" => 71,
			"ErrorDescription" => nil,
			"OriginalAmount" => 2600,
			"VoucherAmount" => 3700,
			"RequiredAmount" => 200,
			"CurrencyISOCode" => "USD",
				#  unique Zapper Transaction Identifier
			"ZapperId" => "HLVZRWTUBP7L",
				#  ID to be used for refunds
			"PaymentId" => 785123,
				# IOM Unique transaction reference number
			"TransactionReference" => "6ae8b2cf-9efd-4881-8387-746487aa3518"
		}
		apply_ticket_value(resp)
	end

	def example_check
		resp = {
			"errorDescription" => nil,
			"errorId" => 0,
			"statusId" => 1,
			"status" => "Success",
			"message" => nil,
			"data" => [
				{"PosReference" => "ZAPPER01",
					"PaymentItems" =>
					[{"PaymentStatusId" => 1,
						"PaymentStatus" => "Success",
						"InvoiceAmount" => 12.5700,
						"ZapperDiscountAmount" => 0.0000,
						"TipAmount" => 1.5700,
						"AmountPaid" => 14.1400,
						"ErrorId" => nil,
						"ErrorDescription" => ""
					}]
				}],
			"authenticationToken":"00000000-0000-0000-0000-000000000000"
		}
		apply_ticket_success(resp)
	end

end


# "merchantSiteID" = "Zapper Merchant Location ID. It is only required should you need to poll to verify the status of a transaction"
# "ZapperID" = "a unique transaction response. The customer can use this to query the payment as we send an email with this reference in it"




# https://2.zap.pe

# ------------------------        CREATE PAYMENT

# route -> ZAP_REQ_URL/payments/CreateCustomerAndInitiatePayment



# ------------------------               POLL FOR RESPONSE


# route -> ZAP_REQ_URL/payments/GetMultiplePaymentStatusByPosReferences?merchantsiteId={merchantsiteID}&posreference={posReference}
